---
title: "ODE stepping and control"
output: bookdown::html_document2
---

**authors**: DS Falster
**date**: 2023

The `plant` model uses am explicit Runge-Kutta ODE stepper to integrate the differential equations that need to be solved (for overview of these see XXXX).  The particular method used is Runge-Kutta Cash-Karp 4-5 algorithm, with adpative time step. You can read more about Runge-Kutta methods and adpative time steps on Wikipedia at <https://en.wikipedia.org/wiki/Runge-Kutta_methods>. 

The solver is controlled by a set of parameters that determine how the solver steps through time. 

The code is built into the model, based on  code ported directly from the [GNU Scientific Library](http://www.gnu.org/software/gsl/)
[@Galassi-2009]. 

# Setup in C++



# Controls on ODE stepping

The solver is controlled by a set of parameters that determine how the solver steps through time. 

As a simple example, we can step a system using the default values for ODE stepping:

```{r}
library(plant)

# configure a patch containing a single species
p <- 
  scm_base_parameters("FF16") %>%
  expand_parameters(trait_matrix(0.0825, "lma"), .)

# Controls on numerical methods
ctrl <- fast_control()

# run
out <- run_scm(p, ctrl = ctrl)

# number of steps
length(out$ode_times)
```

The precise times used by the solver are stored in `out$ode_times`, so the length of this object indicates the numebr of times used. 

The number and timing of steps taken by the solver will vary with the controls on the ode solver.  Looking at the ctrl object, we can extract the items beginning with `ode_`, which control the ODE solver:

```{r}
ctrl %>% subset(grepl("(?<!n)ode_", names(.), perl = TRUE))
````

These have the following effect

- `ode_step_size_initial`: The initial step size used by the solver in the first step.
- `ode_step_size_min`, `ode_step_size_max`: The minimum step size permitted. Any attempt by the solver to use a smaller value will be curtialed at this value. 
- `ode_tol_abs`, `ode_tol_rel`: When taking a step, the absolute and relative error for any single equation that is allowed. If the error is too high, the solver will attempt to take a smaller step. If the error is well below this value, the solver attempts to expand the step size in the next step. 
- `ode_a_y`, `ode_a_dydt`: Weightings on y and dy/dt, in calculation of allowable relative error (see `OdeControl::errlevel`).

Varying these will potentially change the number of steps taken by the solver. 

However, note that unlike a regular ode solver, the number of steps taken is also influenced by the timing of node introduction. The ode stepper will only expand the time step up until the next node introduction event, for any species. So the node scheduling sets an upper limit on the size of time steps. In the default setup, the node schedule primiarly determines the timesteps in the first months of the simulation. After that, the ode stepper takes a bigger control.

## Varying the 


current system in NodeSchedule interweaves ode_times and node_schedule_times.  


```{r}
plant_log_console()
params <- scm_base_parameters("FF16")
params$max_patch_lifetime <- 10

# configure a patch containing a single species:
p0 <- expand_parameters(trait_matrix(0.0825, "lma"), params)
p1 <- build_schedule(p0)
out0 <- run_scm(p0)
out0 <- run_scm_collect(p0)

p0$ode_times <- rep(0.1, 100

all.equal(p1, p0)
all.equal(p1$node_schedule_times, p0$node_schedule_times)

p1b <- p1
p1b$ode_times <- p1$ode_times[-c(205:210)]

out0 <- run_scm(p0)
out1 <- run_scm(p1)
out2 <- run_scm(p1, use_ode_times = TRUE)
out2b <- run_scm(p1b, use_ode_times = TRUE)

length(p1$ode_times)
length(p1b$ode_times)

length(out0$ode_times)
length(out1$ode_times)
length(out2$ode_times)
length(out2b$ode_times)

p1

names(result)
length(result$ode_times)

result$ode_times |>
  diff() %>%
  range()
```

# Limiting the Minimum and Maximum step size

Let's alter the maximum step size and compare to what we had above.

```{r}
ctrl2 <- ctrl
ctrl2$ode_step_size_max <- 0.1

# run
out2 <- run_scm(p, ctrl = ctrl2)

# compare
length(out$ode_times)
length(out2$ode_times)

# maximum
f <- function(ode_times, title = "
") {
diff(ode_times) %>% hist(main = title, xlim = c(0,2), breaks  =seq(0, 2, length.out=20), freq = FALSE)}

f(out$ode_times, "original")
f(out2$ode_times, "max 0.1")
```

Now let's alter the minimum step size and compare to what we had above.

```{r}
ctrl3 <- ctrl
ctrl3$ode_step_size_min <- 0.01
ctrl3$ode_step_size_initial <- 0.01

# run
out3 <- run_scm(p, ctrl = ctrl3)

# compare
length(out$ode_times)
length(out3$ode_times)

f(out$ode_times, "original")
f(out3$ode_times, "min 0.01")
```


# Can we limit step sizes at lower end?

```{r}
ctrl <- scm_base_control()
ctrl$ode_step_size_min <- 0.01
ctrl$ode_step_size_initial <- 0.01

p0b <- p0
p0b$node_schedule_times[[1]] <- c(0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0)
result2 <- run_scm(p0b, ctrl = ctrl)

result2$ode_times
```

# Can we fix step sizes?

## Option 1
yes, by specifying ode_times in parameters

```{r}
ctrl <- scm_base_control()

p0c <- p0
p0c$node_schedule_times[[1]] <- c(0, 0.11, 0.41, 0.81, 1.21)
p0c$ode_times <- seq(0, p0$max_patch_lifetime, by=0.02)

result2 <- run_scm(p0c, ctrl = ctrl, use_ode_times = TRUE)

result2$ode_times
```

## Option 2
yes, by specifying max and min step sizes. But this could result in odd times, dpeending on the cohort schedule

```{r}
ctrl <- scm_base_control()
ctrl$ode_step_size_min <- 0.1
ctrl$ode_step_size_max <- 0.1
ctrl$ode_step_size_initial <- 0.1

p0c <- p0
p0c$node_schedule_times[[1]] <- c(0, 0.11, 0.44, 0.88, 1.212)

result2 <- run_scm(p0c, ctrl = ctrl)

result2$ode_times
```

# How do we want to contol ode_times? 

current can provide with pars, but this is a bit clunky. could have option to pass in ode_times, use if supplied?

- But, current system in NodeSchedule interweaves ode_times and node_schedule_times. It's complex code, poorly documented, low value to emss with. Suggests leaving as is
- could have option to pass in ode_times, add to pars inside function, use if supplied?
- if supplied, do we always want to use ode_times?
- what's the advantage of using previous ode_times?
  - suggest always using them if present?

# Better document 

Need easy demo showing how to make desired changes

- how to change ode_times
- how to specify fixed ode_times

Need a graphic of document saying how all the parts/classes of the odesolver relate to each other

ode controls

- controls: ode_step_size_initial, ode_step_size_min, ode_step_size_max, ode_tol_rel, ode_tol_abs, ode_a_y, ode_a_dydt
- What is ode_a_y and ode_a_dydt?
- these arse used in ode_control. But there the ode_ prefix is removed. Should we rename them there to have same name and so are easier to find


