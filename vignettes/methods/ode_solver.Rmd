---
title: "ODE stepping and control"
output: bookdown::html_document2
---

**authors**: DS Falster
**date**: 2023

The `plant` model uses am explicit Runge-Kutta ODE stepper to integrate the ordinary differential equations that describe the system. (For details on these see <demography.html> and <solving_dynamics.html>.) Specifically, we use the Runge-Kutta Cash-Karp 4-5 algorithm, with adpative time step. In brief, this means that the solver takes a step through time, and then evaluates the error in the step. Error is estimated by comparing two possible steps: one using 4 sub-intervals, and one using 5 sub-intervals. By comparing the step made with more sub-intervals, the algorithm can estimate the non-linearity in the system and error in the step. If the error is too high, the solver will attempt to take a smaller step. If the error is well below a target value, the solver will attempt to take a larger step. Importantly, the 5 step reuses information from the 4 step and thereby only requires a single extra call on rates of change, so the RK45 algorithm is much more efficient than alternatives like the RK4-8. The math of RK45 stepping has long been established, and the method is available in most solvers for ODE systems. You can read more about Runge-Kutta methods and adpative time steps on Wikipedia at <https://en.wikipedia.org/wiki/Runge-Kutta_methods>. 

# Setup in C++

The characteristic method used to solve density requires regular introduction of new nodes, which entails a resizing of the ODE system as the system progresses. To make this play nicely with the ODE stepping, Rich FitzJohn deisgned a custom ODE solver class based on the RK45 method. The code is built into the model, with some details ported from the [GNU Scientific Library](http://www.gnu.org/software/gsl/) [@Galassi-2009]. 

The main interface is described in the class `plant::ode::Solver` described in the file  `ode_solver.h`. The class is established using a template `System` class, meaning you can effectively cast any variety of classes as an ODE Solver. (In a similar way, you can create a vector of any variety of data types.) 

From `ode_solver.h`:
```c
template <class System>
class Solver {
public:
  Solver(const System& system, OdeControl control_);
  ...
```

## Solving an entire patch

The main solver for the system is the class `SCM`, (in the file `sch.h`). This creates an ode solver based on patch type. Simultaenously, the class `SCM` owns an actual instance of the patch:

```c
patch_type patch;                 # Instance of patch
ode::Solver<patch_type> solver;   # ODE solver
```

All we need to do to advance the system is make calls like the following. These advance the system, using the patch to estimate rates of change. Moreoever, we can take steps of a specified fixed size, or an adapative step where the solver determines the spacing 

```c
solver.advance_fixed(patch, e.times);  
solver.advance_adaptive(patch, e.time_end());
```
In the background, the solver then passes information (rates of change, states) between the actual patch (which contains all the biological information informing rates of change) and ode solver (which uses the RK4 math to caluclate future states from rates of change).

Additonally, we have the following function, which resizes the ODE system after a node has been introduced.

```c
solver.set_state_from_system(patch)
```

For the above to work, the patch class (see `patch.h`) must has some essential functions used by the ODE system. 

```c
// * ODE interface
// Caluclate size of ode system (number of equations).
size_t ode_size() const;
// How many auxiallary variables are we tracking. These are being collected but
// are not part of core ode system
size_t aux_size() const;
double ode_time() const;

// Retrieve ode state from patch and save into the ode solver
ode::iterator ode_state(ode::iterator it) const;
// Retrieve ode rates from patch and save into the ode solver
ode::iterator ode_rates(ode::iterator it) const;
// Retrieve auxillary variables and save into the ode solver
ode::iterator ode_aux(ode::iterator it) const;

// Set state of patch, based on estimate of future state estimated by the solver
ode::const_iterator set_ode_state(ode::const_iterator it, double time);
```

Note the use of iterators. These enable state from a complicated data structure like a patch, to be converted into a vector, as needed by ode solver. And vice versa. 

## Solving individuals

### Via ode Runner


OdeRunner:

```c
template <typename T>
class Runner {
public:
  Runner(T obj_, OdeControl control) : obj(obj_), solver(obj, control) {}
```` 


# Controls on ODE stepping

The solver is controlled by a set of parameters that determine how the solver steps through time. 

As a simple example, we can step a system using the default values for ODE stepping:

```{r}
library(plant)

# configure a patch containing a single species
p <- 
  scm_base_parameters("FF16") %>%
  expand_parameters(trait_matrix(0.0825, "lma"), .)

# Controls on numerical methods
ctrl <- fast_control()

# run
out <- run_scm(p, ctrl = ctrl)

# number of steps
length(out$ode_times)
```

The precise times used by the solver are stored in `out$ode_times`, so the length of this object indicates the numebr of times used. 

The number and timing of steps taken by the solver will vary with the controls on the ode solver.  Looking at the ctrl object, we can extract the items beginning with `ode_`, which control the ODE solver:

```{r}
ctrl %>% subset(grepl("(?<!n)ode_", names(.), perl = TRUE))
````

These have the following effect

- `ode_step_size_initial`: The initial step size used by the solver in the first step.
- `ode_step_size_min`, `ode_step_size_max`: The minimum step size permitted. Any attempt by the solver to use a smaller value will be curtialed at this value. 
- `ode_tol_abs`, `ode_tol_rel`: When taking a step, the absolute and relative error for any single equation that is allowed. If the error is too high, the solver will attempt to take a smaller step. If the error is well below this value, the solver attempts to expand the step size in the next step. 
- `ode_a_y`, `ode_a_dydt`: Weightings on y and dy/dt, in calculation of allowable relative error (see `OdeControl::errlevel`).

Varying these will potentially change the number of steps taken by the solver. 

However, note that unlike a regular ode solver, the number of steps taken is also influenced by the timing of node introduction. The ode stepper will only expand the time step up until the next node introduction event, for any species. So the node scheduling sets an upper limit on the size of time steps. In the default setup, the node schedule primiarly determines the timesteps in the first months of the simulation. After that, the ode stepper takes a bigger control.

## Varying the 


current system in NodeSchedule interweaves ode_times and node_schedule_times.  


```{r, eval = FALSE}
plant_log_console()
params <- scm_base_parameters("FF16")
params$max_patch_lifetime <- 10

# configure a patch containing a single species:
p0 <- expand_parameters(trait_matrix(0.0825, "lma"), params)
p1 <- build_schedule(p0)
out0 <- run_scm(p0)
out0 <- run_scm_collect(p0)

p0$ode_times <- rep(0.1, 100

all.equal(p1, p0)
all.equal(p1$node_schedule_times, p0$node_schedule_times)

p1b <- p1
p1b$ode_times <- p1$ode_times[-c(205:210)]

out0 <- run_scm(p0)
out1 <- run_scm(p1)
out2 <- run_scm(p1, use_ode_times = TRUE)
out2b <- run_scm(p1b, use_ode_times = TRUE)

length(p1$ode_times)
length(p1b$ode_times)

length(out0$ode_times)
length(out1$ode_times)
length(out2$ode_times)
length(out2b$ode_times)

p1

names(result)
length(result$ode_times)

result$ode_times |>
  diff() %>%
  range()
```

# Limiting the Minimum and Maximum step size

Let's alter the maximum step size and compare to what we had above.

```{r, eval = FALSE}
ctrl2 <- ctrl
ctrl2$ode_step_size_max <- 0.1

# run
out2 <- run_scm(p, ctrl = ctrl2)

# compare
length(out$ode_times)
length(out2$ode_times)

# maximum
f <- function(ode_times, title = "
") {
diff(ode_times) %>% hist(main = title, xlim = c(0,2), breaks  =seq(0, 2, length.out=20), freq = FALSE)}

f(out$ode_times, "original")
f(out2$ode_times, "max 0.1")
```

Now let's alter the minimum step size and compare to what we had above.

```{r, eval = FALSE}
ctrl3 <- ctrl
ctrl3$ode_step_size_min <- 0.01
ctrl3$ode_step_size_initial <- 0.01

# run
out3 <- run_scm(p, ctrl = ctrl3)

# compare
length(out$ode_times)
length(out3$ode_times)

f(out$ode_times, "original")
f(out3$ode_times, "min 0.01")
```


# Can we limit step sizes at lower end?

```{r, eval = FALSE}
ctrl <- scm_base_control()
ctrl$ode_step_size_min <- 0.01
ctrl$ode_step_size_initial <- 0.01

p0b <- p0
p0b$node_schedule_times[[1]] <- c(0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0)
result2 <- run_scm(p0b, ctrl = ctrl)

result2$ode_times
```

# Can we fix step sizes?

## Option 1
yes, by specifying ode_times in parameters

```{r, eval = FALSE}
ctrl <- scm_base_control()

p0c <- p0
p0c$node_schedule_times[[1]] <- c(0, 0.11, 0.41, 0.81, 1.21)
p0c$ode_times <- seq(0, p0$max_patch_lifetime, by=0.02)

result2 <- run_scm(p0c, ctrl = ctrl, use_ode_times = TRUE)

result2$ode_times
```

## Option 2
yes, by specifying max and min step sizes. But this could result in odd times, dpeending on the cohort schedule

```{r, eval = FALSE}
ctrl <- scm_base_control()
ctrl$ode_step_size_min <- 0.1
ctrl$ode_step_size_max <- 0.1
ctrl$ode_step_size_initial <- 0.1

p0c <- p0
p0c$node_schedule_times[[1]] <- c(0, 0.11, 0.44, 0.88, 1.212)

result2 <- run_scm(p0c, ctrl = ctrl)

result2$ode_times
```

# How do we want to contol ode_times? 

current can provide with pars, but this is a bit clunky. could have option to pass in ode_times, use if supplied?

- But, current system in NodeSchedule interweaves ode_times and node_schedule_times. It's complex code, poorly documented, low value to emss with. Suggests leaving as is
- could have option to pass in ode_times, add to pars inside function, use if supplied?
- if supplied, do we always want to use ode_times?
- what's the advantage of using previous ode_times?
  - suggest always using them if present?

# Better document 

Need easy demo showing how to make desired changes

- how to change ode_times
- how to specify fixed ode_times

Need a graphic of document saying how all the parts/classes of the odesolver relate to each other

ode controls

- controls: ode_step_size_initial, ode_step_size_min, ode_step_size_max, ode_tol_rel, ode_tol_abs, ode_a_y, ode_a_dydt
- What is ode_a_y and ode_a_dydt?
- these arse used in ode_control. But there the ode_ prefix is removed. Should we rename them there to have same name and so are easier to find


